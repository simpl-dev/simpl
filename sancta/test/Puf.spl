grammar puf.spl.Puf;

// options (backtrack=true;)

Program: Include? decls=FunDecl+;

Include: "#" "include" file=Id ".puf"; 

option Decl {
    def left: DeclLeft
    def expr: Expr
    // TODO: unapply for pattern matching.
}: TupleDecl | FunDecl;

TupleDecl: left=TupleLeft "=" expr=Expr ";";
FunDecl: left=FunLeft "=" expr=Expr ";";
option DeclLeft: FunLeft | TupleLeft;
FunLeft returns DeclLeft: Id+;
TupleLeft returns DeclLeft: "(" h=Id ("," t=Id)* ")";

option Expr: 
	CaseExpr 
	| LetrecExpr 
	| LetExpr 
	| FunExpr 
	| IfExpr 
	| OrExpr;

CaseExpr: "case" expr=Expr "of" nilAlt=NilAlt ";" consAlt=ConsAlt;
NilAlt: "[" "]" "->" expr=Expr;
ConsAlt: head=Id ":" tail=Id "->" expr=Expr;
LetrecExpr: "letrec" decl=FunDecl+ "in" Expr;
LetExpr: "let" decl=Decl+ "in" Expr;
FunExpr: "fn" params=Id+ "->" Expr;
IfExpr: "if" cond=Expr "then" ifThen=Expr "else" ifElse=Expr;

OrExpr returns {makeBinaryOps(BinaryOp.Or, left :: rest)}:
    left=AndExpr ("||" rest=AndExpr)*;
AndExpr returns Expr {makeBinaryOps(BinaryOp.And, left :: rest)}:
    left=EqExpr ("&&" rest=EqExpr)*;

EqExpr returns Expr {
    if (right eq null)
        left
    else
        makeBinaryOp(op.text, left, right)
    }: left=CompareExpr (op=EqOp right=CompareExpr)?;
terminal EqOp: "==" | "/=";

CompareExpr returns Expr: left=ConsExpr (op=CompareOp right=ConsExpr)?;
terminal CompareOp: "<" | "<=" | ">" | ">=";

ConsExpr returns Expr: left=PlusExpr (":" right=ConsExpr)?;

PlusExpr returns Expr: left=MulExpr (op=PlusExprOp rest=MulExpr)*;
option PlusExprOp {
    def text: String
}: PlusOp | MinusOp;
terminal PlusOp: "+";
terminal MinusOp: "-";

MulExpr returns Expr: left=UnaryExpr (op=MulExprOp rest=UnaryExpr)*;
terminal MulExprOp: "*" | "/" | "%";

option UnaryExpr returns Expr: 
    NegExpr 
    | NotExpr 
    | SelectExpr 
    | ApplyExpr;
NegExpr: MinusOp expr=PrimaryExpr;
NotExpr: "not" expr=PrimaryExpr;
ApplyExpr: fun=PrimaryExpr (params=PrimaryExpr)*;
SelectExpr: "#" sel=Num tuple=PrimaryExpr;

option PrimaryExpr returns Expr:
    Id 
    | Num 
    | TupleLiteral
    | ListLiteral
    ;
TupleLiteral:
    "(" ")"
    | "(" first=Expr ("," rest=Expr)* ")";
ListLiteral: 
    "[" "]" 
    | "[" first=Expr ("," rest=Expr)+ "]";

terminal Str: '"' ~('"')* '"';
terminal Id: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal Num: ('0'..'9')+;
fragment MlComment: '/*' (~'*' | '*' ~'/')* '*/';
fragment SlComment: '//' ~('\n'|'\r')*;
hidden terminal Ws: (' '|'\t'|'\r'|'\n'|MlComment|SlComment)+;